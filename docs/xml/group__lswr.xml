<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.14.0" xml:lang="fr">
  <compounddef id="group__lswr" kind="group">
    <compoundname>lswr</compoundname>
    <title>libswresample</title>
    <innerfile refid="swresample_8h">swresample.h</innerfile>
    <sectiondef kind="user-defined">
      <header>Option constants</header>
      <description><para>These constants are used for the <ref refid="group__avoptions" kindref="compound">AVOptions</ref> interface for lswr. </para>
</description>
      <memberdef kind="enum" id="group__lswr_1ga387e613b19e5269a46d9ff1a5ee3fcd4" prot="public" static="no" strong="no">
        <type></type>
        <name>SwrDitherType</name>
        <enumvalue id="group__lswr_1gga387e613b19e5269a46d9ff1a5ee3fcd4afacc17a82581598f762a8036ba559836" prot="public">
          <name>SWR_DITHER_NONE</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lswr_1gga387e613b19e5269a46d9ff1a5ee3fcd4a0fec2dd28b1357b50e9807ca6ecee83a" prot="public">
          <name>SWR_DITHER_RECTANGULAR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lswr_1gga387e613b19e5269a46d9ff1a5ee3fcd4ae4635dc355dc680eeb211e7af17ddfd2" prot="public">
          <name>SWR_DITHER_TRIANGULAR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lswr_1gga387e613b19e5269a46d9ff1a5ee3fcd4a91276f2e437aa9d0d8bdffabe24f5532" prot="public">
          <name>SWR_DITHER_TRIANGULAR_HIGHPASS</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lswr_1gga387e613b19e5269a46d9ff1a5ee3fcd4ae6858a54f5b2e1bffa9aaef20b2593c0" prot="public">
          <name>SWR_DITHER_NS</name>
          <initializer>= 64</initializer>
          <briefdescription>
<para>not part of API/ABI </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lswr_1gga387e613b19e5269a46d9ff1a5ee3fcd4a6f6072071262f7f05a52057cfe48df87" prot="public">
          <name>SWR_DITHER_NS_LIPSHITZ</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lswr_1gga387e613b19e5269a46d9ff1a5ee3fcd4ae197d7fc5592652aaa8edf1067c56af9" prot="public">
          <name>SWR_DITHER_NS_F_WEIGHTED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lswr_1gga387e613b19e5269a46d9ff1a5ee3fcd4a60eeb8ca5de47916a81f2c3a6534eed4" prot="public">
          <name>SWR_DITHER_NS_MODIFIED_E_WEIGHTED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lswr_1gga387e613b19e5269a46d9ff1a5ee3fcd4ad13d2ff2831d463eb46ca4c46dfec7b0" prot="public">
          <name>SWR_DITHER_NS_IMPROVED_E_WEIGHTED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lswr_1gga387e613b19e5269a46d9ff1a5ee3fcd4ae3aba4bf43c2210a148b11c0215b5d24" prot="public">
          <name>SWR_DITHER_NS_SHIBATA</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lswr_1gga387e613b19e5269a46d9ff1a5ee3fcd4af275c21089abbf78a6623544f34d76f9" prot="public">
          <name>SWR_DITHER_NS_LOW_SHIBATA</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lswr_1gga387e613b19e5269a46d9ff1a5ee3fcd4ac569828a706ccf22a8d5810c973c8f17" prot="public">
          <name>SWR_DITHER_NS_HIGH_SHIBATA</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lswr_1gga387e613b19e5269a46d9ff1a5ee3fcd4aacbdf2f91bb14cf390116492115fb8ea" prot="public">
          <name>SWR_DITHER_NB</name>
          <briefdescription>
<para>not part of API/ABI </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Dithering algorithms </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" line="148" column="1" bodyfile="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" bodystart="148" bodyend="163"/>
      </memberdef>
      <memberdef kind="enum" id="group__lswr_1ga87f9e023bbe780d3ccf17dfc7abed580" prot="public" static="no" strong="no">
        <type></type>
        <name>SwrEngine</name>
        <enumvalue id="group__lswr_1gga87f9e023bbe780d3ccf17dfc7abed580a11652db5af0c279d79deba1c577c9729" prot="public">
          <name>SWR_ENGINE_SWR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>SW Resampler </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lswr_1gga87f9e023bbe780d3ccf17dfc7abed580a2933f5b0b96829095a04a8acd19b27e7" prot="public">
          <name>SWR_ENGINE_SOXR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>SoX Resampler </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lswr_1gga87f9e023bbe780d3ccf17dfc7abed580a865af2e70ebb85b3cafb93f1854dbef9" prot="public">
          <name>SWR_ENGINE_NB</name>
          <briefdescription>
<para>not part of API/ABI </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Resampling Engines </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" line="166" column="1" bodyfile="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" bodystart="166" bodyend="170"/>
      </memberdef>
      <memberdef kind="enum" id="group__lswr_1ga2176b2a3a8b809788f6e7ccdc238b6be" prot="public" static="no" strong="no">
        <type></type>
        <name>SwrFilterType</name>
        <enumvalue id="group__lswr_1gga2176b2a3a8b809788f6e7ccdc238b6bea1a6413b9888bac851e2ee4f991f01d0c" prot="public">
          <name>SWR_FILTER_TYPE_CUBIC</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Cubic </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lswr_1gga2176b2a3a8b809788f6e7ccdc238b6bea17f5dd4512b4abc2285905293a81cf55" prot="public">
          <name>SWR_FILTER_TYPE_BLACKMAN_NUTTALL</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Blackman Nuttall windowed sinc </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__lswr_1gga2176b2a3a8b809788f6e7ccdc238b6bea8f492a5dc94b6e41a37f190c5492bf3f" prot="public">
          <name>SWR_FILTER_TYPE_KAISER</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Kaiser windowed sinc </para>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Resampling Filter Types </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" line="173" column="1" bodyfile="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" bodystart="173" bodyend="177"/>
      </memberdef>
      <memberdef kind="define" id="group__lswr_1ga2226aca7f49137f3f29b6f731a985916" prot="public" static="no">
        <name>SWR_FLAG_RESAMPLE</name>
        <initializer>1</initializer>
        <briefdescription>
<para>Force resampling even if equal sample rate. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" line="143" column="9" bodyfile="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" bodystart="143" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="user-defined">
      <header>SwrContext constructor functions</header>
      <memberdef kind="function" id="group__lswr_1ga17283a2547f79f4013ba32820ec86ca8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>struct <ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref> *</type>
        <definition>struct SwrContext * swr_alloc</definition>
        <argsstring>(void)</argsstring>
        <name>swr_alloc</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Allocate <ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref>.</para>
<para>If you use this function you will need to set the parameters (manually or with <ref refid="group__lswr_1ga803ae19bc1c32a20a691996b4e530f22" kindref="member">swr_alloc_set_opts2()</ref>) before calling <ref refid="group__lswr_1gae173e8ed91717700471a1dcd06f00f67" kindref="member">swr_init()</ref>.</para>
<para><simplesect kind="see"><para><ref refid="group__lswr_1ga803ae19bc1c32a20a691996b4e530f22" kindref="member">swr_alloc_set_opts2()</ref>, <ref refid="group__lswr_1gae173e8ed91717700471a1dcd06f00f67" kindref="member">swr_init()</ref>, <ref refid="group__lswr_1ga818f7d78b1ad7d8d5b70de374b668c34" kindref="member">swr_free()</ref> </para>
</simplesect>
<simplesect kind="return"><para>NULL on error, allocated context otherwise </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" line="214" column="17" declfile="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" declline="214" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="group__lswr_1gae173e8ed91717700471a1dcd06f00f67" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int swr_init</definition>
        <argsstring>(struct SwrContext *s)</argsstring>
        <name>swr_init</name>
        <param>
          <type>struct <ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref> *</type>
          <declname>s</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Initialize context after user parameters have been set. <simplesect kind="note"><para>The context must be configured using the <ref refid="struct_a_v_option" kindref="compound">AVOption</ref> API.</para>
</simplesect>
<simplesect kind="see"><para>av_opt_set_int() </para>
</simplesect>
<simplesect kind="see"><para><ref refid="group__opt__write_1gaf1a88e8f152d7835f111b1ef8813fb2e" kindref="member">av_opt_set_dict()</ref></para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">s</parametername>
</parameternamelist>
<parameterdescription>
<para>Swr context to initialize </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>AVERROR error code in case of failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" line="226" column="5" declfile="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" declline="226" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__lswr_1gab11b02705e97404b6d74b18b2fcfdfcf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int swr_is_initialized</definition>
        <argsstring>(struct SwrContext *s)</argsstring>
        <name>swr_is_initialized</name>
        <param>
          <type>struct <ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref> *</type>
          <declname>s</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Check whether an swr context has been initialized or not.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">s</parametername>
</parameternamelist>
<parameterdescription>
<para>Swr context to check </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="group__lswr_1gae173e8ed91717700471a1dcd06f00f67" kindref="member">swr_init()</ref> </para>
</simplesect>
<simplesect kind="return"><para>positive if it has been initialized, 0 if not initialized </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" line="235" column="5" declfile="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" declline="235" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__lswr_1ga803ae19bc1c32a20a691996b4e530f22" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int swr_alloc_set_opts2</definition>
        <argsstring>(struct SwrContext **ps, const AVChannelLayout *out_ch_layout, enum AVSampleFormat out_sample_fmt, int out_sample_rate, const AVChannelLayout *in_ch_layout, enum AVSampleFormat in_sample_fmt, int in_sample_rate, int log_offset, void *log_ctx)</argsstring>
        <name>swr_alloc_set_opts2</name>
        <param>
          <type>struct <ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref> **</type>
          <declname>ps</declname>
        </param>
        <param>
          <type>const <ref refid="struct_a_v_channel_layout" kindref="compound">AVChannelLayout</ref> *</type>
          <declname>out_ch_layout</declname>
        </param>
        <param>
          <type>enum <ref refid="group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5" kindref="member">AVSampleFormat</ref></type>
          <declname>out_sample_fmt</declname>
        </param>
        <param>
          <type>int</type>
          <declname>out_sample_rate</declname>
        </param>
        <param>
          <type>const <ref refid="struct_a_v_channel_layout" kindref="compound">AVChannelLayout</ref> *</type>
          <declname>in_ch_layout</declname>
        </param>
        <param>
          <type>enum <ref refid="group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5" kindref="member">AVSampleFormat</ref></type>
          <declname>in_sample_fmt</declname>
        </param>
        <param>
          <type>int</type>
          <declname>in_sample_rate</declname>
        </param>
        <param>
          <type>int</type>
          <declname>log_offset</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>log_ctx</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Allocate <ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref> if needed and set/reset common parameters.</para>
<para>This function does not require *ps to be allocated with <ref refid="group__lswr_1ga17283a2547f79f4013ba32820ec86ca8" kindref="member">swr_alloc()</ref>. On the other hand, <ref refid="group__lswr_1ga17283a2547f79f4013ba32820ec86ca8" kindref="member">swr_alloc()</ref> can use <ref refid="group__lswr_1ga803ae19bc1c32a20a691996b4e530f22" kindref="member">swr_alloc_set_opts2()</ref> to set the parameters on the allocated context.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ps</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to an existing Swr context if available, or to NULL if not. On success, *ps will be set to the allocated context. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>out_ch_layout</parametername>
</parameternamelist>
<parameterdescription>
<para>output channel layout (e.g. AV_CHANNEL_LAYOUT_*) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>out_sample_fmt</parametername>
</parameternamelist>
<parameterdescription>
<para>output sample format (AV_SAMPLE_FMT_*). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>out_sample_rate</parametername>
</parameternamelist>
<parameterdescription>
<para>output sample rate (frequency in Hz) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>in_ch_layout</parametername>
</parameternamelist>
<parameterdescription>
<para>input channel layout (e.g. AV_CHANNEL_LAYOUT_*) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>in_sample_fmt</parametername>
</parameternamelist>
<parameterdescription>
<para>input sample format (AV_SAMPLE_FMT_*). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>in_sample_rate</parametername>
</parameternamelist>
<parameterdescription>
<para>input sample rate (frequency in Hz) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>log_offset</parametername>
</parameternamelist>
<parameterdescription>
<para>logging level offset </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>log_ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>parent logging context, can be NULL</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="group__lswr_1gae173e8ed91717700471a1dcd06f00f67" kindref="member">swr_init()</ref>, <ref refid="group__lswr_1ga818f7d78b1ad7d8d5b70de374b668c34" kindref="member">swr_free()</ref> </para>
</simplesect>
<simplesect kind="return"><para>0 on success, a negative AVERROR code on error. On error, the Swr context is freed and *ps set to NULL. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" line="259" column="5" declfile="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" declline="259" declcolumn="5"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="user-defined">
      <header>SwrContext destructor functions</header>
      <memberdef kind="function" id="group__lswr_1ga818f7d78b1ad7d8d5b70de374b668c34" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void swr_free</definition>
        <argsstring>(struct SwrContext **s)</argsstring>
        <name>swr_free</name>
        <param>
          <type>struct <ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref> **</type>
          <declname>s</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Free the given <ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref> and set the pointer to NULL.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">s</parametername>
</parameternamelist>
<parameterdescription>
<para>a pointer to a pointer to Swr context </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" line="275" column="6" declfile="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" declline="275" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__lswr_1gaa4bf1048740dfc08d68aba9f1b4db22e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void swr_close</definition>
        <argsstring>(struct SwrContext *s)</argsstring>
        <name>swr_close</name>
        <param>
          <type>struct <ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref> *</type>
          <declname>s</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Closes the context so that <ref refid="group__lswr_1gab11b02705e97404b6d74b18b2fcfdfcf" kindref="member">swr_is_initialized()</ref> returns 0.</para>
<para>The context can be brought back to life by running <ref refid="group__lswr_1gae173e8ed91717700471a1dcd06f00f67" kindref="member">swr_init()</ref>, <ref refid="group__lswr_1gae173e8ed91717700471a1dcd06f00f67" kindref="member">swr_init()</ref> can also be used without <ref refid="group__lswr_1gaa4bf1048740dfc08d68aba9f1b4db22e" kindref="member">swr_close()</ref>. This function is mainly provided for simplifying the usecase where one tries to support libavresample and libswresample.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">s</parametername>
</parameternamelist>
<parameterdescription>
<para>Swr context to be closed </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" line="287" column="6" declfile="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" declline="287" declcolumn="6"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="user-defined">
      <header>Core conversion functions</header>
      <memberdef kind="function" id="group__lswr_1gad16a8308503be52a7e2d460983e81460" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int swr_convert</definition>
        <argsstring>(struct SwrContext *s, uint8_t *const *out, int out_count, const uint8_t *const *in, int in_count)</argsstring>
        <name>swr_convert</name>
        <param>
          <type>struct <ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type>uint8_t *const *</type>
          <declname>out</declname>
        </param>
        <param>
          <type>int</type>
          <declname>out_count</declname>
        </param>
        <param>
          <type>const uint8_t *const *</type>
          <declname>in</declname>
        </param>
        <param>
          <type>int</type>
          <declname>in_count</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert audio.</para>
<para>in and in_count can be set to 0 to flush the last few samples out at the end.</para>
<para>If more input is provided than output space, then the input will be buffered. You can avoid this buffering by using <ref refid="group__lswr_1ga97a8d5f6abe3bcdfb6072412f17285a4" kindref="member">swr_get_out_samples()</ref> to retrieve an upper bound on the required number of output samples for the given number of input samples. Conversion will run directly without copying whenever possible.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>allocated Swr context, with parameters set </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>out</parametername>
</parameternamelist>
<parameterdescription>
<para>output buffers, only the first one need be set in case of packed audio </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>out_count</parametername>
</parameternamelist>
<parameterdescription>
<para>amount of space available for output in samples per channel </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>in</parametername>
</parameternamelist>
<parameterdescription>
<para>input buffers, only the first one need to be set in case of packed audio </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>in_count</parametername>
</parameternamelist>
<parameterdescription>
<para>number of input samples available in one channel</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>number of samples output per channel, negative value on error </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" line="314" column="5" declfile="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" declline="314" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__lswr_1gaad9811626c6c01a241f6bf46aff27333" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int64_t</type>
        <definition>int64_t swr_next_pts</definition>
        <argsstring>(struct SwrContext *s, int64_t pts)</argsstring>
        <name>swr_next_pts</name>
        <param>
          <type>struct <ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>pts</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert the next timestamp from input to output timestamps are in 1/(in_sample_rate * out_sample_rate) units.</para>
<para><simplesect kind="note"><para>There are 2 slightly differently behaving modes. <itemizedlist>
<listitem><para>When automatic timestamp compensation is not used, (min_compensation &gt;= FLT_MAX) in this case timestamps will be passed through with delays compensated </para>
</listitem>
<listitem><para>When automatic timestamp compensation is used, (min_compensation &lt; FLT_MAX) in this case the output timestamps will match output sample numbers. See ffmpeg-resampler(1) for the two modes of compensation.</para>
</listitem>
</itemizedlist>
</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">s</parametername>
</parameternamelist>
<parameterdescription>
<para>initialized Swr context </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">pts</parametername>
</parameternamelist>
<parameterdescription>
<para>timestamp for the next input sample, INT64_MIN if unknown </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="group__lswr_1gab7f21690522b85d7757e13fa9853d4d8" kindref="member">swr_set_compensation()</ref>, <ref refid="group__lswr_1ga43d7ba4507891fc25aacbbea5cdfb065" kindref="member">swr_drop_output()</ref>, and <ref refid="group__lswr_1ga4733ed4779ed3e30379de2a6ef8de837" kindref="member">swr_inject_silence()</ref> are function used internally for timestamp compensation. </para>
</simplesect>
<simplesect kind="return"><para>the output timestamp for the next output sample </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" line="334" column="9" declfile="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" declline="334" declcolumn="9"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="user-defined">
      <header>Low-level option setting functions</header>
      <description><para>These functions provide a means to set low-level options that is not possible with the <ref refid="struct_a_v_option" kindref="compound">AVOption</ref> API. </para>
</description>
      <memberdef kind="function" id="group__lswr_1gab7f21690522b85d7757e13fa9853d4d8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int swr_set_compensation</definition>
        <argsstring>(struct SwrContext *s, int sample_delta, int compensation_distance)</argsstring>
        <name>swr_set_compensation</name>
        <param>
          <type>struct <ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type>int</type>
          <declname>sample_delta</declname>
        </param>
        <param>
          <type>int</type>
          <declname>compensation_distance</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Activate resampling compensation (&quot;soft&quot; compensation). This function is internally called when needed in <ref refid="group__lswr_1gaad9811626c6c01a241f6bf46aff27333" kindref="member">swr_next_pts()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">s</parametername>
</parameternamelist>
<parameterdescription>
<para>allocated Swr context. If it is not initialized, or SWR_FLAG_RESAMPLE is not set, <ref refid="group__lswr_1gae173e8ed91717700471a1dcd06f00f67" kindref="member">swr_init()</ref> is called with the flag set. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">sample_delta</parametername>
</parameternamelist>
<parameterdescription>
<para>delta in PTS per sample </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">compensation_distance</parametername>
</parameternamelist>
<parameterdescription>
<para>number of samples to compensate for </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>&gt;= 0 on success, AVERROR error codes if: <itemizedlist>
<listitem><para><computeroutput>s</computeroutput> is NULL, </para>
</listitem>
<listitem><para><computeroutput>compensation_distance</computeroutput> is less than 0, </para>
</listitem>
<listitem><para><computeroutput>compensation_distance</computeroutput> is 0 but sample_delta is not, </para>
</listitem>
<listitem><para>compensation unsupported by resampler, or </para>
</listitem>
<listitem><para><ref refid="group__lswr_1gae173e8ed91717700471a1dcd06f00f67" kindref="member">swr_init()</ref> fails when called. </para>
</listitem>
</itemizedlist>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" line="361" column="5" declfile="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" declline="361" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__lswr_1ga1b528050b5f5b704aecbfbc257a17ef0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int swr_set_channel_mapping</definition>
        <argsstring>(struct SwrContext *s, const int *channel_map)</argsstring>
        <name>swr_set_channel_mapping</name>
        <param>
          <type>struct <ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>channel_map</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set a customized input channel mapping.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">s</parametername>
</parameternamelist>
<parameterdescription>
<para>allocated Swr context, not yet initialized </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">channel_map</parametername>
</parameternamelist>
<parameterdescription>
<para>customized input channel mapping (array of channel indexes, -1 for a muted channel) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>&gt;= 0 on success, or AVERROR error code in case of failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" line="371" column="5" declfile="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" declline="371" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__lswr_1ga6a9f82de302424551f8af5b91d229394" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int swr_build_matrix2</definition>
        <argsstring>(const AVChannelLayout *in_layout, const AVChannelLayout *out_layout, double center_mix_level, double surround_mix_level, double lfe_mix_level, double maxval, double rematrix_volume, double *matrix, ptrdiff_t stride, enum AVMatrixEncoding matrix_encoding, void *log_context)</argsstring>
        <name>swr_build_matrix2</name>
        <param>
          <type>const <ref refid="struct_a_v_channel_layout" kindref="compound">AVChannelLayout</ref> *</type>
          <declname>in_layout</declname>
        </param>
        <param>
          <type>const <ref refid="struct_a_v_channel_layout" kindref="compound">AVChannelLayout</ref> *</type>
          <declname>out_layout</declname>
        </param>
        <param>
          <type>double</type>
          <declname>center_mix_level</declname>
        </param>
        <param>
          <type>double</type>
          <declname>surround_mix_level</declname>
        </param>
        <param>
          <type>double</type>
          <declname>lfe_mix_level</declname>
        </param>
        <param>
          <type>double</type>
          <declname>maxval</declname>
        </param>
        <param>
          <type>double</type>
          <declname>rematrix_volume</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>matrix</declname>
        </param>
        <param>
          <type>ptrdiff_t</type>
          <declname>stride</declname>
        </param>
        <param>
          <type>enum AVMatrixEncoding</type>
          <declname>matrix_encoding</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>log_context</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Generate a channel mixing matrix.</para>
<para>This function is the one used internally by libswresample for building the default mixing matrix. It is made public just as a utility function for building custom matrices.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>in_layout</parametername>
</parameternamelist>
<parameterdescription>
<para>input channel layout </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>out_layout</parametername>
</parameternamelist>
<parameterdescription>
<para>output channel layout </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>center_mix_level</parametername>
</parameternamelist>
<parameterdescription>
<para>mix level for the center channel </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>surround_mix_level</parametername>
</parameternamelist>
<parameterdescription>
<para>mix level for the surround channel(s) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lfe_mix_level</parametername>
</parameternamelist>
<parameterdescription>
<para>mix level for the low-frequency effects channel </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rematrix_maxval</parametername>
</parameternamelist>
<parameterdescription>
<para>if 1.0, coefficients will be normalized to prevent overflow. if INT_MAX, coefficients will not be normalized. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">matrix</parametername>
</parameternamelist>
<parameterdescription>
<para>mixing coefficients; matrix[i + stride * o] is the weight of input channel i in output channel o. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stride</parametername>
</parameternamelist>
<parameterdescription>
<para>distance between adjacent input channels in the matrix array </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>matrix_encoding</parametername>
</parameternamelist>
<parameterdescription>
<para>matrixed stereo downmix mode (e.g. dplii) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>log_ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>parent logging context, can be NULL </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success, negative AVERROR code on failure </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" line="396" column="5" declfile="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" declline="396" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__lswr_1gaf9064d65b1e654dc78f7d6bcd2e8c747" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int swr_set_matrix</definition>
        <argsstring>(struct SwrContext *s, const double *matrix, int stride)</argsstring>
        <name>swr_set_matrix</name>
        <param>
          <type>struct <ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>matrix</declname>
        </param>
        <param>
          <type>int</type>
          <declname>stride</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set a customized remix matrix.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>allocated Swr context, not yet initialized </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>matrix</parametername>
</parameternamelist>
<parameterdescription>
<para>remix coefficients; matrix[i + stride * o] is the weight of input channel i in output channel o </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stride</parametername>
</parameternamelist>
<parameterdescription>
<para>offset between lines of the matrix </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>&gt;= 0 on success, or AVERROR error code in case of failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" line="412" column="5" declfile="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" declline="412" declcolumn="5"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="user-defined">
      <header>Sample handling functions</header>
      <memberdef kind="function" id="group__lswr_1ga43d7ba4507891fc25aacbbea5cdfb065" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int swr_drop_output</definition>
        <argsstring>(struct SwrContext *s, int count)</argsstring>
        <name>swr_drop_output</name>
        <param>
          <type>struct <ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type>int</type>
          <declname>count</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Drops the specified number of output samples.</para>
<para>This function, along with <ref refid="group__lswr_1ga4733ed4779ed3e30379de2a6ef8de837" kindref="member">swr_inject_silence()</ref>, is called by <ref refid="group__lswr_1gaad9811626c6c01a241f6bf46aff27333" kindref="member">swr_next_pts()</ref> if needed for &quot;hard&quot; compensation.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>allocated Swr context </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>number of samples to be dropped</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>&gt;= 0 on success, or a negative AVERROR code on failure </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" line="432" column="5" declfile="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" declline="432" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__lswr_1ga4733ed4779ed3e30379de2a6ef8de837" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int swr_inject_silence</definition>
        <argsstring>(struct SwrContext *s, int count)</argsstring>
        <name>swr_inject_silence</name>
        <param>
          <type>struct <ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type>int</type>
          <declname>count</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Injects the specified number of silence samples.</para>
<para>This function, along with <ref refid="group__lswr_1ga43d7ba4507891fc25aacbbea5cdfb065" kindref="member">swr_drop_output()</ref>, is called by <ref refid="group__lswr_1gaad9811626c6c01a241f6bf46aff27333" kindref="member">swr_next_pts()</ref> if needed for &quot;hard&quot; compensation.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>allocated Swr context </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>number of samples to be dropped</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>&gt;= 0 on success, or a negative AVERROR code on failure </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" line="445" column="5" declfile="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" declline="445" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__lswr_1ga5121a5a7890a2d23b72dc871dd0ebb06" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int64_t</type>
        <definition>int64_t swr_get_delay</definition>
        <argsstring>(struct SwrContext *s, int64_t base)</argsstring>
        <name>swr_get_delay</name>
        <param>
          <type>struct <ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>base</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Gets the delay the next input sample will experience relative to the next output sample.</para>
<para>Swresample can buffer data if more input has been provided than available output space, also converting between sample rates needs a delay. This function returns the sum of all such delays. The exact delay is not necessarily an integer value in either input or output sample rate. Especially when downsampling by a large value, the output sample rate may be a poor choice to represent the delay, similarly for upsampling and the input sample rate.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>swr context </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>base</parametername>
</parameternamelist>
<parameterdescription>
<para>timebase in which the returned delay will be: <itemizedlist>
<listitem><para>if it&apos;s set to 1 the returned delay is in seconds </para>
</listitem>
<listitem><para>if it&apos;s set to 1000 the returned delay is in milliseconds </para>
</listitem>
<listitem><para>if it&apos;s set to the input sample rate then the returned delay is in input samples </para>
</listitem>
<listitem><para>if it&apos;s set to the output sample rate then the returned delay is in output samples </para>
</listitem>
<listitem><para>if it&apos;s the least common multiple of in_sample_rate and out_sample_rate then an exact rounding-free delay will be returned </para>
</listitem>
</itemizedlist>
</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the delay in 1 / <computeroutput>base</computeroutput> units. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" line="471" column="9" declfile="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" declline="471" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="group__lswr_1ga97a8d5f6abe3bcdfb6072412f17285a4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int swr_get_out_samples</definition>
        <argsstring>(struct SwrContext *s, int in_samples)</argsstring>
        <name>swr_get_out_samples</name>
        <param>
          <type>struct <ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type>int</type>
          <declname>in_samples</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Find an upper bound on the number of samples that the next swr_convert call will output, if called with in_samples of input samples. This depends on the internal state, and anything changing the internal state (like further <ref refid="group__lswr_1gad16a8308503be52a7e2d460983e81460" kindref="member">swr_convert()</ref> calls) will may change the number of samples <ref refid="group__lswr_1ga97a8d5f6abe3bcdfb6072412f17285a4" kindref="member">swr_get_out_samples()</ref> returns for the same number of input samples.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>in_samples</parametername>
</parameternamelist>
<parameterdescription>
<para>number of input samples. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>any call to <ref refid="group__lswr_1ga4733ed4779ed3e30379de2a6ef8de837" kindref="member">swr_inject_silence()</ref>, <ref refid="group__lswr_1gad16a8308503be52a7e2d460983e81460" kindref="member">swr_convert()</ref>, <ref refid="group__lswr_1gaad9811626c6c01a241f6bf46aff27333" kindref="member">swr_next_pts()</ref> or <ref refid="group__lswr_1gab7f21690522b85d7757e13fa9853d4d8" kindref="member">swr_set_compensation()</ref> invalidates this limit </para>
</simplesect>
<simplesect kind="note"><para>it is recommended to pass the correct available buffer size to all functions like <ref refid="group__lswr_1gad16a8308503be52a7e2d460983e81460" kindref="member">swr_convert()</ref> even if <ref refid="group__lswr_1ga97a8d5f6abe3bcdfb6072412f17285a4" kindref="member">swr_get_out_samples()</ref> indicates that less would be used. </para>
</simplesect>
<simplesect kind="return"><para>an upper bound on the number of samples that the next swr_convert will output or a negative value to indicate an error </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" line="489" column="5" declfile="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" declline="489" declcolumn="5"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="user-defined">
      <header>Configuration accessors</header>
      <memberdef kind="function" id="group__lswr_1gaed39c2153a1e26b4ef656ec8c765a2e3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>unsigned</type>
        <definition>unsigned swresample_version</definition>
        <argsstring>(void)</argsstring>
        <name>swresample_version</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return the LIBSWRESAMPLE_VERSION_INT constant.</para>
<para>This is useful to check if the build-time libswresample has the same version as the run-time one.</para>
<para><simplesect kind="return"><para>the unsigned int-typed version </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" line="506" column="10" declfile="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" declline="506" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="group__lswr_1gacb05ad2022842645a473d46212461be7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const char *</type>
        <definition>const char * swresample_configuration</definition>
        <argsstring>(void)</argsstring>
        <name>swresample_configuration</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return the swr build-time configuration.</para>
<para><simplesect kind="return"><para>the build-time <computeroutput></computeroutput>./configure flags </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" line="513" column="12" declfile="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" declline="513" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="group__lswr_1ga138666c7d154a3b3a10cfe490b752266" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const char *</type>
        <definition>const char * swresample_license</definition>
        <argsstring>(void)</argsstring>
        <name>swresample_license</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return the swr license.</para>
<para><simplesect kind="return"><para>the license of libswresample, determined at build-time </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" line="520" column="12" declfile="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" declline="520" declcolumn="12"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="user-defined">
      <header>AVFrame based API</header>
      <memberdef kind="function" id="group__lswr_1gac482028c01d95580106183aa84b0930c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int swr_convert_frame</definition>
        <argsstring>(SwrContext *swr, AVFrame *output, const AVFrame *input)</argsstring>
        <name>swr_convert_frame</name>
        <param>
          <type><ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref> *</type>
          <declname>swr</declname>
        </param>
        <param>
          <type><ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> *</type>
          <declname>output</declname>
        </param>
        <param>
          <type>const <ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> *</type>
          <declname>input</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert the samples in the input <ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> and write them to the output <ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref>.</para>
<para>Input and output AVFrames must have channel_layout, sample_rate and format set.</para>
<para>If the output <ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> does not have the data pointers allocated the nb_samples field will be set using <ref refid="group__lavu__frame_1ga6b1acbfa82c79bf7fd78d868572f0ceb" kindref="member">av_frame_get_buffer()</ref> is called to allocate the frame.</para>
<para>The output <ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> can be NULL or have fewer allocated samples than required. In this case, any remaining samples not written to the output will be added to an internal FIFO buffer, to be returned at the next call to this function or to <ref refid="group__lswr_1gad16a8308503be52a7e2d460983e81460" kindref="member">swr_convert()</ref>.</para>
<para>If converting sample rate, there may be data remaining in the internal resampling delay buffer. <ref refid="group__lswr_1ga5121a5a7890a2d23b72dc871dd0ebb06" kindref="member">swr_get_delay()</ref> tells the number of remaining samples. To get this data as output, call this function or <ref refid="group__lswr_1gad16a8308503be52a7e2d460983e81460" kindref="member">swr_convert()</ref> with NULL input.</para>
<para>If the <ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref> configuration does not match the output and input <ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> settings the conversion does not take place and depending on which <ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> is not matching AVERROR_OUTPUT_CHANGED, AVERROR_INPUT_CHANGED or the result of a bitwise-OR of them is returned.</para>
<para><simplesect kind="see"><para>swr_delay() </para>
</simplesect>
<simplesect kind="see"><para><ref refid="group__lswr_1gad16a8308503be52a7e2d460983e81460" kindref="member">swr_convert()</ref> </para>
</simplesect>
<simplesect kind="see"><para><ref refid="group__lswr_1ga5121a5a7890a2d23b72dc871dd0ebb06" kindref="member">swr_get_delay()</ref></para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>swr</parametername>
</parameternamelist>
<parameterdescription>
<para>audio resample context </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>output</parametername>
</parameternamelist>
<parameterdescription>
<para>output <ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>input</parametername>
</parameternamelist>
<parameterdescription>
<para>input <ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success, AVERROR on failure or nonmatching configuration. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" line="563" column="5" declfile="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" declline="563" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__lswr_1ga73ade2cf6934765cf518c6c917b77c76" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int swr_config_frame</definition>
        <argsstring>(SwrContext *swr, const AVFrame *out, const AVFrame *in)</argsstring>
        <name>swr_config_frame</name>
        <param>
          <type><ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref> *</type>
          <declname>swr</declname>
        </param>
        <param>
          <type>const <ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> *</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const <ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> *</type>
          <declname>in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Configure or reconfigure the <ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref> using the information provided by the AVFrames.</para>
<para>The original resampling context is reset even on failure. The function calls <ref refid="group__lswr_1gaa4bf1048740dfc08d68aba9f1b4db22e" kindref="member">swr_close()</ref> internally if the context is open.</para>
<para><simplesect kind="see"><para><ref refid="group__lswr_1gaa4bf1048740dfc08d68aba9f1b4db22e" kindref="member">swr_close()</ref>;</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>swr</parametername>
</parameternamelist>
<parameterdescription>
<para>audio resample context </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>out</parametername>
</parameternamelist>
<parameterdescription>
<para>output <ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>in</parametername>
</parameternamelist>
<parameterdescription>
<para>input <ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success, AVERROR on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" line="580" column="5" declfile="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" declline="580" declcolumn="5"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="typedef">
      <memberdef kind="typedef" id="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" prot="public" static="no">
        <type>struct <ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref></type>
        <definition>typedef struct SwrContext SwrContext</definition>
        <argsstring></argsstring>
        <name>SwrContext</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The libswresample context. Unlike libavcodec and libavformat, this structure is opaque. This means that if you would like to set options, you must use the <ref refid="group__avoptions" kindref="compound">AVOptions</ref> API and cannot directly set values to members of the structure. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" line="189" column="25" bodyfile="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" bodystart="189" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="func">
      <memberdef kind="function" id="group__lswr_1gaabeac14d6aa684de193c65b6e34c4901" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="struct_a_v_class" kindref="compound">AVClass</ref> *</type>
        <definition>const AVClass * swr_get_class</definition>
        <argsstring>(void)</argsstring>
        <name>swr_get_class</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the <ref refid="struct_a_v_class" kindref="compound">AVClass</ref> for <ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref>. It can be used in combination with AV_OPT_SEARCH_FAKE_OBJ for examining options.</para>
<para><simplesect kind="see"><para><ref refid="group__opt__mng_1ga9ad3a0b722a9815f15e3df512290d618" kindref="member">av_opt_find()</ref>. </para>
</simplesect>
<simplesect kind="return"><para>the <ref refid="struct_a_v_class" kindref="compound">AVClass</ref> of <ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" line="198" column="15" declfile="C:/Users/ahumeaub/Desktop/CLionProject/ClassSynchroniseurMultiVideo/include/ffmpeg/include/libswresample/swresample.h" declline="198" declcolumn="15"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Audio resampling, sample format conversion and mixing library.</para>
<para>Interaction with lswr is done through <ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref>, which is allocated with <ref refid="group__lswr_1ga17283a2547f79f4013ba32820ec86ca8" kindref="member">swr_alloc()</ref> or <ref refid="group__lswr_1ga803ae19bc1c32a20a691996b4e530f22" kindref="member">swr_alloc_set_opts2()</ref>. It is opaque, so all parameters must be set with the <ref refid="group__avoptions" kindref="compound">AVOptions</ref> API.</para>
<para>The first thing you will need to do in order to use lswr is to allocate <ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref>. This can be done with <ref refid="group__lswr_1ga17283a2547f79f4013ba32820ec86ca8" kindref="member">swr_alloc()</ref> or <ref refid="group__lswr_1ga803ae19bc1c32a20a691996b4e530f22" kindref="member">swr_alloc_set_opts2()</ref>. If you are using the former, you must set options through the <ref refid="group__avoptions" kindref="compound">AVOptions</ref> API. The latter function provides the same feature, but it allows you to set some common options in the same statement.</para>
<para>For example the following code will setup conversion from planar float sample format to interleaved signed 16-bit integer, downsampling from 48kHz to 44.1kHz and downmixing from 5.1 channels to stereo (using the default mixing matrix). This is using the <ref refid="group__lswr_1ga17283a2547f79f4013ba32820ec86ca8" kindref="member">swr_alloc()</ref> function. <programlisting><codeline><highlight class="normal"><ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref><sp/>*swr<sp/>=<sp/><ref refid="group__lswr_1ga17283a2547f79f4013ba32820ec86ca8" kindref="member">swr_alloc</ref>();</highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__opt__set__funcs_1gac111d12d38108a9f19004b16437a9647" kindref="member">av_opt_set_chlayout</ref>(swr,<sp/></highlight><highlight class="stringliteral">&quot;in_chlayout&quot;</highlight><highlight class="normal">,<sp/>&amp;(<ref refid="struct_a_v_channel_layout" kindref="compound">AVChannelLayout</ref>)AV_CHANNEL_LAYOUT_5POINT1,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__opt__set__funcs_1gac111d12d38108a9f19004b16437a9647" kindref="member">av_opt_set_chlayout</ref>(swr,<sp/></highlight><highlight class="stringliteral">&quot;out_chlayout&quot;</highlight><highlight class="normal">,<sp/>&amp;(<ref refid="struct_a_v_channel_layout" kindref="compound">AVChannelLayout</ref>)AV_CHANNEL_LAYOUT_STEREO,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal">av_opt_set_int(swr,<sp/></highlight><highlight class="stringliteral">&quot;in_sample_rate&quot;</highlight><highlight class="normal">,<sp/><sp/><sp/><sp/><sp/>48000,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0);</highlight></codeline>
<codeline><highlight class="normal">av_opt_set_int(swr,<sp/></highlight><highlight class="stringliteral">&quot;out_sample_rate&quot;</highlight><highlight class="normal">,<sp/><sp/><sp/><sp/>44100,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0);</highlight></codeline>
<codeline><highlight class="normal">av_opt_set_sample_fmt(swr,<sp/></highlight><highlight class="stringliteral">&quot;in_sample_fmt&quot;</highlight><highlight class="normal">,<sp/><sp/><ref refid="group__lavu__sampfmts_1ggaf9a51ca15301871723577c730b5865c5a2d21c520e4ab21100b6440ec2d81ba1b" kindref="member">AV_SAMPLE_FMT_FLTP</ref>,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal">av_opt_set_sample_fmt(swr,<sp/></highlight><highlight class="stringliteral">&quot;out_sample_fmt&quot;</highlight><highlight class="normal">,<sp/><ref refid="group__lavu__sampfmts_1ggaf9a51ca15301871723577c730b5865c5aea6132df57aebc3f76e10665395c46af" kindref="member">AV_SAMPLE_FMT_S16</ref>,<sp/><sp/>0);</highlight></codeline>
</programlisting></para>
<para>The same job can be done using <ref refid="group__lswr_1ga803ae19bc1c32a20a691996b4e530f22" kindref="member">swr_alloc_set_opts2()</ref> as well: <programlisting><codeline><highlight class="normal"><ref refid="group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863" kindref="member">SwrContext</ref><sp/>*swr<sp/>=<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ret<sp/>=<sp/><ref refid="group__lswr_1ga803ae19bc1c32a20a691996b4e530f22" kindref="member">swr_alloc_set_opts2</ref>(&amp;swr,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>we&apos;re<sp/>allocating<sp/>a<sp/>new<sp/>context</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;(<ref refid="struct_a_v_channel_layout" kindref="compound">AVChannelLayout</ref>)AV_CHANNEL_LAYOUT_STEREO,<sp/></highlight><highlight class="comment">//<sp/>out_ch_layout</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__lavu__sampfmts_1ggaf9a51ca15301871723577c730b5865c5aea6132df57aebc3f76e10665395c46af" kindref="member">AV_SAMPLE_FMT_S16</ref>,<sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>out_sample_fmt</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>44100,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>out_sample_rate</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;(<ref refid="struct_a_v_channel_layout" kindref="compound">AVChannelLayout</ref>)AV_CHANNEL_LAYOUT_5POINT1,<sp/></highlight><highlight class="comment">//<sp/>in_ch_layout</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__lavu__sampfmts_1ggaf9a51ca15301871723577c730b5865c5a2d21c520e4ab21100b6440ec2d81ba1b" kindref="member">AV_SAMPLE_FMT_FLTP</ref>,<sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>in_sample_fmt</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>48000,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>in_sample_rate</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>log_offset</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>NULL);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>log_ctx</highlight></codeline>
</programlisting></para>
<para>Once all values have been set, it must be initialized with <ref refid="group__lswr_1gae173e8ed91717700471a1dcd06f00f67" kindref="member">swr_init()</ref>. If you need to change the conversion parameters, you can change the parameters using <ref refid="group__avoptions" kindref="compound">AVOptions</ref>, as described above in the first example; or by using <ref refid="group__lswr_1ga803ae19bc1c32a20a691996b4e530f22" kindref="member">swr_alloc_set_opts2()</ref>, but with the first argument the allocated context. You must then call <ref refid="group__lswr_1gae173e8ed91717700471a1dcd06f00f67" kindref="member">swr_init()</ref> again.</para>
<para>The conversion itself is done by repeatedly calling <ref refid="group__lswr_1gad16a8308503be52a7e2d460983e81460" kindref="member">swr_convert()</ref>. Note that the samples may get buffered in swr if you provide insufficient output space or if sample rate conversion is done, which requires &quot;future&quot; samples. Samples that do not require future input can be retrieved at any time by using <ref refid="group__lswr_1gad16a8308503be52a7e2d460983e81460" kindref="member">swr_convert()</ref> (in_count can be set to 0). At the end of conversion the resampling buffer can be flushed by calling <ref refid="group__lswr_1gad16a8308503be52a7e2d460983e81460" kindref="member">swr_convert()</ref> with NULL in and 0 in_count.</para>
<para>The samples used in the conversion process can be managed with the libavutil <ref refid="group__lavu__sampmanip" kindref="compound">samples manipulation</ref> API, including <ref refid="group__lavu__sampmanip_1ga4db4c77f928d32c7d8854732f50b8c04" kindref="member">av_samples_alloc()</ref> function used in the following example.</para>
<para>The delay between input and output, can at any time be found by using <ref refid="group__lswr_1ga5121a5a7890a2d23b72dc871dd0ebb06" kindref="member">swr_get_delay()</ref>.</para>
<para>The following code demonstrates the conversion loop assuming the parameters from above and caller-defined functions get_input() and handle_output(): <programlisting><codeline><highlight class="normal">uint8_t<sp/>**input;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>in_samples;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(get_input(&amp;input,<sp/>&amp;in_samples))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>uint8_t<sp/>*output;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>out_samples<sp/>=<sp/><ref refid="group__lavu__math_1ga82d40664213508918093822461cc597e" kindref="member">av_rescale_rnd</ref>(<ref refid="group__lswr_1ga5121a5a7890a2d23b72dc871dd0ebb06" kindref="member">swr_get_delay</ref>(swr,<sp/>48000)<sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>in_samples,<sp/>44100,<sp/>48000,<sp/><ref refid="group__lavu__math_1gga921d656eaf2c4d6800a734a13af021d0aa1d28e08e2f8b49b256e056f93038c1a" kindref="member">AV_ROUND_UP</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__lavu__sampmanip_1ga4db4c77f928d32c7d8854732f50b8c04" kindref="member">av_samples_alloc</ref>(&amp;output,<sp/>NULL,<sp/>2,<sp/>out_samples,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__lavu__sampfmts_1ggaf9a51ca15301871723577c730b5865c5aea6132df57aebc3f76e10665395c46af" kindref="member">AV_SAMPLE_FMT_S16</ref>,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>out_samples<sp/>=<sp/><ref refid="group__lswr_1gad16a8308503be52a7e2d460983e81460" kindref="member">swr_convert</ref>(swr,<sp/>&amp;output,<sp/>out_samples,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>input,<sp/>in_samples);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>handle_output(output,<sp/>out_samples);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__lavu__mem__funcs_1ga0cc84043ea2167ad005c86e11d0bcdba" kindref="member">av_freep</ref>(&amp;output);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>When the conversion is finished, the conversion context and everything associated with it must be freed with <ref refid="group__lswr_1ga818f7d78b1ad7d8d5b70de374b668c34" kindref="member">swr_free()</ref>. A <ref refid="group__lswr_1gaa4bf1048740dfc08d68aba9f1b4db22e" kindref="member">swr_close()</ref> function is also available, but it exists mainly for compatibility with libavresample, and is not required to be called.</para>
<para>There will be no memory leak if the data is not completely flushed before <ref refid="group__lswr_1ga818f7d78b1ad7d8d5b70de374b668c34" kindref="member">swr_free()</ref>. </para>
    </detaileddescription>
  </compounddef>
</doxygen>
