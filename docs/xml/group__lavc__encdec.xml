<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.14.0" xml:lang="fr">
  <compounddef id="group__lavc__encdec" kind="group">
    <compoundname>lavc_encdec</compoundname>
    <title>send/receive encoding and decoding API overview</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>The <ref refid="group__lavc__decoding_1ga58bc4bf1e0ac59e27362597e467efff3" kindref="member">avcodec_send_packet()</ref>/avcodec_receive_frame()/avcodec_send_frame()/ <ref refid="group__lavc__decoding_1ga5b8eff59cf259747cf0b31563e38ded6" kindref="member">avcodec_receive_packet()</ref> functions provide an encode/decode API, which decouples input and output.</para>
<para>The API is very similar for encoding/decoding and audio/video, and works as follows:<itemizedlist>
<listitem><para>Set up and open the <ref refid="struct_a_v_codec_context" kindref="compound">AVCodecContext</ref> as usual.</para>
</listitem><listitem><para>Send valid input:<itemizedlist>
<listitem><para>For decoding, call <ref refid="group__lavc__decoding_1ga58bc4bf1e0ac59e27362597e467efff3" kindref="member">avcodec_send_packet()</ref> to give the decoder raw compressed data in an <ref refid="struct_a_v_packet" kindref="compound">AVPacket</ref>.</para>
</listitem><listitem><para>For encoding, call <ref refid="group__lavc__decoding_1ga9395cb802a5febf1f00df31497779169" kindref="member">avcodec_send_frame()</ref> to give the encoder an <ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> containing uncompressed audio or video.</para>
</listitem></itemizedlist>
</para>
<para>In both cases, it is recommended that AVPackets and AVFrames are refcounted, or libavcodec might have to copy the input data. (libavformat always returns refcounted AVPackets, and <ref refid="group__lavu__frame_1ga6b1acbfa82c79bf7fd78d868572f0ceb" kindref="member">av_frame_get_buffer()</ref> allocates refcounted AVFrames.)</para>
</listitem><listitem><para>Receive output in a loop. Periodically call one of the avcodec_receive_*() functions and process their output:<itemizedlist>
<listitem><para>For decoding, call <ref refid="group__lavc__decoding_1ga11e6542c4e66d3028668788a1a74217c" kindref="member">avcodec_receive_frame()</ref>. On success, it will return an <ref refid="struct_a_v_frame" kindref="compound">AVFrame</ref> containing uncompressed audio or video data.</para>
</listitem><listitem><para>For encoding, call <ref refid="group__lavc__decoding_1ga5b8eff59cf259747cf0b31563e38ded6" kindref="member">avcodec_receive_packet()</ref>. On success, it will return an <ref refid="struct_a_v_packet" kindref="compound">AVPacket</ref> with a compressed frame.</para>
</listitem></itemizedlist>
</para>
<para>Repeat this call until it returns AVERROR(EAGAIN) or an error. The AVERROR(EAGAIN) return value means that new input data is required to return new output. In this case, continue with sending input. For each input frame/packet, the codec will typically return 1 output frame/packet, but it can also be 0 or more than 1.</para>
</listitem></itemizedlist>
</para>
<para>At the beginning of decoding or encoding, the codec might accept multiple input frames/packets without returning a frame, until its internal buffers are filled. This situation is handled transparently if you follow the steps outlined above.</para>
<para>In theory, sending input can result in EAGAIN - this should happen only if not all output was received. You can use this to structure alternative decode or encode loops other than the one suggested above. For example, you could try sending new input on each iteration, and try to receive output if that returns EAGAIN.</para>
<para>End of stream situations. These require &quot;flushing&quot; (aka draining) the codec, as the codec might buffer multiple frames or packets internally for performance or out of necessity (consider B-frames). This is handled as follows:<itemizedlist>
<listitem><para>Instead of valid input, send NULL to the <ref refid="group__lavc__decoding_1ga58bc4bf1e0ac59e27362597e467efff3" kindref="member">avcodec_send_packet()</ref> (decoding) or <ref refid="group__lavc__decoding_1ga9395cb802a5febf1f00df31497779169" kindref="member">avcodec_send_frame()</ref> (encoding) functions. This will enter draining mode.</para>
</listitem><listitem><para>Call <ref refid="group__lavc__decoding_1ga11e6542c4e66d3028668788a1a74217c" kindref="member">avcodec_receive_frame()</ref> (decoding) or <ref refid="group__lavc__decoding_1ga5b8eff59cf259747cf0b31563e38ded6" kindref="member">avcodec_receive_packet()</ref> (encoding) in a loop until AVERROR_EOF is returned. The functions will not return AVERROR(EAGAIN), unless you forgot to enter draining mode.</para>
</listitem><listitem><para>Before decoding can be resumed again, the codec has to be reset with <ref refid="group__lavc__misc_1gaf60b0e076f822abcb2700eb601d352a6" kindref="member">avcodec_flush_buffers()</ref>.</para>
</listitem></itemizedlist>
</para>
<para>Using the API as outlined above is highly recommended. But it is also possible to call functions outside of this rigid schema. For example, you can call <ref refid="group__lavc__decoding_1ga58bc4bf1e0ac59e27362597e467efff3" kindref="member">avcodec_send_packet()</ref> repeatedly without calling <ref refid="group__lavc__decoding_1ga11e6542c4e66d3028668788a1a74217c" kindref="member">avcodec_receive_frame()</ref>. In this case, <ref refid="group__lavc__decoding_1ga58bc4bf1e0ac59e27362597e467efff3" kindref="member">avcodec_send_packet()</ref> will succeed until the codec&apos;s internal buffer has been filled up (which is typically of size 1 per output frame, after initial input), and then reject input with AVERROR(EAGAIN). Once it starts rejecting input, you have no choice but to read at least some output.</para>
<para>Not all codecs will follow a rigid and predictable dataflow; the only guarantee is that an AVERROR(EAGAIN) return value on a send/receive call on one end implies that a receive/send call on the other end will succeed, or at least will not fail with AVERROR(EAGAIN). In general, no codec will permit unlimited buffering of input or output.</para>
<para>A codec is not allowed to return AVERROR(EAGAIN) for both sending and receiving. This would be an invalid state, which could put the codec user into an endless loop. The API has no concept of time either: it cannot happen that trying to do <ref refid="group__lavc__decoding_1ga58bc4bf1e0ac59e27362597e467efff3" kindref="member">avcodec_send_packet()</ref> results in AVERROR(EAGAIN), but a repeated call 1 second later accepts the packet (with no other receive/flush API calls involved). The API is a strict state machine, and the passage of time is not supposed to influence it. Some timing-dependent behavior might still be deemed acceptable in certain cases. But it must never result in both send/receive returning EAGAIN at the same time at any point. It must also absolutely be avoided that the current state is &quot;unstable&quot; and can &quot;flip-flop&quot; between the send/receive APIs allowing progress. For example, it&apos;s not allowed that the codec randomly decides that it actually wants to consume a packet now instead of returning a frame, after it just returned AVERROR(EAGAIN) on an <ref refid="group__lavc__decoding_1ga58bc4bf1e0ac59e27362597e467efff3" kindref="member">avcodec_send_packet()</ref> call. </para>
    </detaileddescription>
  </compounddef>
</doxygen>
